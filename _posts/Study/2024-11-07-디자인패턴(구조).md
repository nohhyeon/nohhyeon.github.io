---
title: 디자인패턴(구조편)
categories: Study
tags:
  - 디자인패턴
---
### 어댑터 (Adapter)

110V 콘센트에 220V 플러그를 꼽으려면 '110V -> 220V 플러그 어댑터'가 필요하다.  
이 처럼 기존의 서로 다른 인터페이스를 맞추기 위해 중간에 두는 무언가를 '어댑터' 라고 한다.

코드에서도 마찬가지다.  
**서로 다른 두 클래스(Client 와 Adaptee) 가 있고, 이 둘은 그대로 둔 채 이 둘의 인터페이스를 연결하고자 어댑터 클래스를 만들어 사용하는 구조**를 어댑터 패턴이라고 한다.  
이 패턴은 **이미 정의된 3자의 인터페이스를 자신의 인터페이스의 모양으로 "인터페이스의 변경" 하고 싶을 때** 사용한다.

![](https://blog.kakaocdn.net/dn/bAgRVy/btqDF1ayTFc/ijlsiFtlo4ykPMx0kMxTy0/img.png)

구체적인 동작은 [[디자인 패턴 6편] 구조 패턴, 어댑터(Adapter)](https://dailyheumsi.tistory.com/189) 참고.

---

### 컴퍼지트 (Composite)

컴퓨터의 파일과 디렉토리를 생각해보자.  
크게 보면 파일과 디렉토리 둘 다 파일 시스템의 한 요소다.  
다른 점이 있다면, 파일은 파일 그 자체인 반면 디렉토리는 파일이나 디렉토리를 담을 수 있다.  
그래서 파일 - 디렉토리 시스템은 구조적으로 디렉토리가 부모가 되고 하위 디렉토리 혹은 파일이 자식이 되는 트리구조다.

이처럼, **여러 개의 클래스가 크게 보면 같은 요소(Component) 에 속하지만, 여기에 속한 어떤 클래스(Composite)가 자기 자신 혹은 다른 클래스(Leaf)를 가질 수 있는 구조**를 컴퍼지트 패턴이라고 한다.  
이 패턴은 **같은 개념의 클래스들 간에 소유 개념을 나타낸 트리 형태 묶고 싶을 때** 사용한다.

![](https://blog.kakaocdn.net/dn/b9RGse/btqDH1gnUiN/494imhovd8kWrLhxGE2lsK/img.png)

구체적인 동작은 [[디자인 패턴 7편] 구조 패턴, 컴퍼지트(Composite)](https://dailyheumsi.tistory.com/193?category=855210) 참고.

---

### 데코레이터 (Decorator)

크리스마스 시즌이 다가와 크리스마스 트리를 샀다고 해보자.  
이 트리를 꾸밀 여러 장식(Decorator)들도 같이 샀다.  
이제 이 크리스마스 트리에 반짝이는 전구를 붙이기도 하고, 트리 볼도 달아준다.  
그런데 뭔가 어울리지 않는 거 같아, 트리볼은 다시 빼고 곰돌이 인형을 달아주었다. 한결 나은 거 같다.

이 처럼 **각각의 기능을 담당하는 클래스(Decorator)들과 이 기능을 적용할 클래스(Component)를 분리한 뒤, 필요에 따라 동적으로 각 기능을 적용할 수 있는 구조**를 데코레이터 패턴이라고 한다.  
이 패턴은 **주요 기능에 경우에 따라 부가적인 기능을 추가하거나 빼고 싶을 때** 사용한다.

![](https://blog.kakaocdn.net/dn/bBRrjm/btqDGfzDLPS/aV6YcRuKqvAvvng46TYvjk/img.png)

구체적인 동작은 [[디자인 패턴 8편] 구조 패턴, 데코레이터(Decorator)](https://dailyheumsi.tistory.com/198?category=855210) 참고.

---

### 프록시 (Proxy)

돈을 대출받기 위해 은행에 가본다고 해보자.  
일반적으로 은행에서는 기본적으로 대출 담당자가 대출 관련 업무를 처리해준다.  
그런데 내가 찾아간 은행 A에서는 대출 담당자 이전에 대출 안내 담당자가 나를 먼저 맞이하여 준다.  
이 담당자를 통해 간단한 서류 작성을 하거나(전처리), 내가 이전에 대출한 기록이 있는 경우 대출 담당자를 통하지 않고도 바로 대출(캐싱)을 해주고 있다.

이처럼, **구체적인 업무를 담당하고 있는 클래스에 접근하기 전에, 간단한 사전 작업 처리하는 클래스(Proxy)를 두는 구조를 프록시 패턴**이라고 한다.  
이 패턴은 **주요 기능이 요청을 받아 수행하기 전에, 이 요청에 대한 부가적인 전처리들을 수행하는 로직을 세우고 싶을 때** 사용한다.

![](https://blog.kakaocdn.net/dn/YZKDU/btqDGJmYL7U/rYiDgcf7dWYQzlHHKXw3Vk/img.png)

구체적인 동작은 [[디자인 패턴 9편] 구조 패턴, 프록시(Proxy)](https://dailyheumsi.tistory.com/201?category=855210) 참고.

> **어댑터와 프록시 패턴의 차이는 뭘까?**
> 
> 두 패턴 모두 기존에 존재하는 두 클래스 중간에 하나의 클래스(어댑터 혹은 프록시)를 두는 구조다.  
> 따라서 전반적인 구조는 같아 보인다. 그럼 두 패턴의 차이는 뭘까?
> 
> 한 마디로 말하면, 의도가 다르다.  
> 어댑터는 하나의 인터페이스 맞추는 게 목적이고,  
> 프록시는 다양한 방식으로 로직 컨트롤이 목적이다.
> 
> 여기에 퍼사드 패턴에 대해 적지는 않았지만 (너무 간단한 내용이라...)  
> 퍼사드 패턴 역시 비슷한 구조인데, 퍼사드는 복잡한 기능을 감추고 이를 하나의 심플한 인터페이스로 제공하는 것이 목적이다.