---

title : "Spring 공부"
categories : study
tag : spring

---
Spring 공부-2

## 컨트롤러
`@Controller` 애너테이션은 HelloController 클래스가 컨트롤러의 기능을 수행한다는 의미이다. 이 애너테이션이 있어야 스프링 부트 프레임워크가 컨트롤러로 인식한다.
> 자바의 애너테이션(annotation)이란 자바의 클래스, 메서드, 변수 등에 정보를 부여하여 부가 동작을 할 수 있게 하는 목적으로 사용된다.

---

!!**Get 방식과 Post 방식은 어떻게 다를까?**!!

Get과 Post는 HTTP 프로토콜을 사용하여 데이터를 서버로 전송하는 주요 방식이다. 먼저, Get 방식은 데이터를 URL에 노출시켜 요청하며, 주로 서버에서 데이터를 조회하거나 읽기 위한 목적으로 사용한다. 반면, Post 방식은 데이터를 숨겨서 요청하므로 로그인 정보와 같은 민감한 데이터를 서버에 제출하거나 저장하는 목적으로 사용한다.

---

## Spring Boot Devtools 

프로그램을 간단히 수정하더라도 변경된 사항을 확인하기 위해 매번 서버를 재시작해야 하므로 개발 과정이 꽤 번거롭다. 그래서 스프링 부트 Devtools를 추가하면 서버를 매번 재시작하지 않고도 수정한 내용이 반영된다.
!--developmentOnly: 해당 라이브러리는 개발 환경에만 적용된다는 의미로, 운영 환경에 배포되는 jar, war 파일에는 이 라이브러리가 포함되지 않는다.--!

---

## 롬복(Lombok)

롬복(Lombok) 라이브러리는 소스 코드를 작성할 때 자바 클래스에 애너테이션을 사용하여 자주 쓰는 Getter 메서드, Setter 메서드, 생성자 등을 자동으로 만들어 주는 도구이다.

- `final`은 뒤에 따라오는 자료형과 변수 등을 변경할 수 없게 만드는 키워드이다. 만약 클래스 속성을 정의한 코드에 `final`이 없다면 생성자에 포함되지 않는다. 또한 `final`을 적용하면 속성값을 변경할 수 없기 때문에 `@Setter`는 의미가 없어지고, `Setter` 메서드 또한 사용할수 없다

**HTML, CSS, 자바스크립트란?**

웹 개발이 처음이라도 웹 개발의 필수 언어인 HTML, CSS, 자바스크립트라는 용어는 익숙할 것이다. 이를 간단히 소개하면 HTML은 웹 페이지의 기본 구조를 만들 수 있는 마크업 언어다. CSS는 웹 페이지에 옷을 입히는 스타일 시트 언어다. 그리고 자바스크립트는 웹 페이지의 상호 작용과 동작 등을 할 수 있게 만드는 프로그래밍 언어다.

---
### templates 디렉터리

`src/main/resources` 디렉터리의 하위 디렉터리인 templates에는 템플릿 파일을 저장한다. 템플릿 파일은 자바 코드를 삽입할 수 있는 HTML 형식의 파일로, 스프링 부트에서 생성한 자바 객체를 HTML 형태로 출력할 수 있다.

---
### static 디렉터리

static 디렉터리에는 프로젝트의 스타일시트(css 파일), 자바스크립트(js 파일) 그리고 이미지 파일(jpg 파일, png 파일 등) 등을 저장한다.

---
### application.properties 파일

application.properties 파일은 프로젝트의 환경을 설정한다. sbb 프로젝트의 환경 변수, 데이터베이스 등의 설정을 이 파일에 저장한다.

---
## src/test/java 디렉터리

`src/test/java` 디렉터리는 sbb 프로젝트에서 작성한 파일을 테스트하는 코드를 저장하는 공간이다. JUnit과 스프링 부트의 테스트 도구를 사용하여 서버를 실행하지 않은 상태에서 `src/main/java` 디렉터리에 작성한 코드를 테스트할 수 있다.

> JUnit은 테스트 코드를 작성하고, 작성한 테스트 코드를 실행할 때 사용하는 자바의 테스트 프레임워크이다.

---
### build.gradle 파일 

`build.gradle`은 그레이들(Gradle)이 사용하는 환경 파일이다. 그레이들은 그루비(Groovy)를 기반으로 한 빌드 도구로 Ant, Maven과 같은 이전 세대의 단점을 보완하고 장점을 취합하여 만들었다. build.gradle 파일에는 프로젝트에 필요한 플러그인과 라이브러리를 설치하기 위한 내용을 작성한다.

> - 그루비는 그레이들 빌드 스크립트를 작성하는 데 사용하는 스크립트 언어로, 문법이 간결하고 가독성이 높다.
> - 빌드 도구는 소스 코드를 컴파일하고 필요한 라이브러리를 내려받을 때 사용한다. SBB 프로젝트를 완성하면 단 한 개의 jar 파일로 패키징하여 서버에 배포할 수 있는데 이때에도 역시 빌드 도구를 사용한다.

---

**ORM의 장점

ORM을 이용하면 MySQL, 오라클 DB, MS SQL과 같은 DBMS의 종류에 관계 없이 일관된 자바 코드를 사용할 수 있어서 프로그램을 유지·보수하기가 편리하다. 또한 코드 내부에서 안정적인 SQL 쿼리문을 자동으로 생성해 주므로, 개발자가 달라도 통일된 쿼리문을 작성할 수 있고, 오류 발생률도 줄일 수 있다.

---

**DBMS란?**

DBMS(database management system)란 데이터베이스를 관리하는 소프트웨어이다. DB와 DBMS를 구분하지 않고 사용하는 경우가 많은데, 엄밀히 말해 DB는 데이터를 담은 통이라 할 수 있고, DBMS는 이 통을 관리하는 소프트웨어이다.

---
### JPA란?

스프링 부트는 JPA(Java Persistence API)를 사용하여 데이터베이스를 관리한다. 스프링 부트는 JPA를 ORM(Object-Relational Mapping) 기술의 표준으로 사용한다. JPA는 인터페이스 모음이므로, 이 인터페이스를 구현한 실제 클래스가 필요하다. JPA를 구현한 실제 클래스에는 대표적으로 하이버네이트(Hibernate)가 있다. 정리하자면, 하이버네이트는 JPA의 인터페이스를 구현한 실제 클래스이자 자바의 ORM 프레임워크로, 스프링 부트에서 데이터베이스를 관리하기 쉽게 도와준다. 우리가 계속 만들어 갈 SBB도 JPA와 하이버네이트 조합으로 데이터베이스를 관리한다.

> 인터페이스(interface)란 클래스가 구현해야 하는 메서드 목록을 정의한 틀이다.

---

**implementation이란?**

`build.gradle` 파일에서 작성한 `implementation`은 필요한 라이브러리 설치를 위해 가장 일반적으로 사용하는 설정이다. `implementation`은 해당 라이브러리가 변경되더라도 이 라이브러리와 연관된 모든 모듈을 컴파일하지 않고 변경된 내용과 관련이 있는 모듈만 컴파일하므로 프로젝트를 리빌드(rebuild)하는 속도가 빠르다.

---

**spring.jpa.hibernate.ddl-auto`의 규칙**

우리는 `spring.jpa.hibernate.ddl-auto`를 `update`로 설정했다. 또 어떤 설정값이 있는지 간단히 알아보자.

- `none`: 엔티티가 변경되더라도 데이터베이스를 변경하지 않는다.
- `update`: 엔티티의 변경된 부분만 데이터베이스에 적용한다.
- `validate`: 엔티티와 테이블 간에 차이점이 있는지 검사만 한다.
- `create`: 스프링 부트 서버를 시작할 때 테이블을 모두 삭제한 후 다시 생성한다.
- `create-drop`: `create`와 동일하지만 스프링 부트 서버를 종료할 때에도 테이블을 모두 삭제한다.

개발 환경에서는 보통 `update` 모드를 사용하고, 운영 환경에서는 `none` 또는 `validate`를 주로 사용한다.

---
### @Id 애너테이션

id 속성에 적용한 @Id 애너테이션은 id 속성을 기본키로 지정한다. id 속성을 기본키로 지정한 이유는 id 속성의 고유 번호들은 엔티티에서 각 데이터들을 구분하는 유효한 값으로, 중복되면 안 되기 때문이다.

---
### @GeneratedValue 애너테이션

@GeneratedValue 애너테이션을 적용하면 데이터를 저장할 때 해당 속성에 값을 일일이 입력하지 않아도 자동으로 1씩 증가하여 저장된다. `strategy = GenerationType.IDENTITY`는 고유한 번호를 생성하는 방법을 지정하는 부분으로, `GenerationType.IDENTITY`는 해당 속성만 별도로 번호가 차례대로 늘어나도록 할 때 사용한다.

> strategy 옵션을 생략한다면 @GeneratedValue 애너테이션이 지정된 모든 속성에 번호를 차례로 생성하므로 순서가 일정한 고유 번호를 가질 수 없게 된다. 이러한 이유로 보통 `strategy = GenerationType.IDENTITY`를 많이 사용한다.

---
### @Column 애너테이션

엔티티의 속성은 테이블의 열 이름과 일치하는데 열의 세부 설정을 위해 @Column 애너테이션을 사용한다. length는 열의 길이를 설정할 때 사용하고(여기서는 열의 길이를 200으로 정했다.), columnDefinition은 열 데이터의 유형이나 성격을 정의할 때 사용한다. 여기서 columnDefinition = "TEXT"는 말 그대로 ‘텍스트’를 열 데이터로 넣을 수 있음을 의미하고, 글자 수를 제한할 수 없는 경우에 사용한다.

> 엔티티의 속성은 @Column 애너테이션을 사용하지 않더라도 테이블의 열로 인식한다. 테이블의 열로 인식하고 싶지 않다면 @Transient 애너테이션을 사용한다. @Transient 애너테이션은 엔티티의 속성을 테이블의 열로 만들지 않고 클래스의 속성 기능으로만 사용하고자 할 때 쓴다.

---

**엔티티의 속성 이름과 테이블의 열 이름의 차이

Question 엔티티에서 작성 일시에 해당하는 createDate 속성의 이름은 데이터베이스의 테이블에서는 create_date라는 열 이름으로 설정된다. 즉, createDate처럼 카멜 케이스(camel case) 형식의 이름은 create_date처럼 모두 소문자로 변경되고 단어가 언더바(`_`)로 구분되어 데이터베이스 테이블의 열 이름이 된다.

> 카멜 케이스는 맨 첫 글자를 제외한 나머지 단어의 첫 글자를 대문자로 써 구분하는 작명 방식을 말한다.

---

**엔티티를 만들 때 Setter 메서드는 사용하지 않는다**

일반적으로 엔티티를 만들 때에는 Setter 메서드를 사용하지 않기를 권한다. 왜냐하면 엔티티는 데이터베이스와 바로 연결되므로 데이터를 자유롭게 변경할 수 있는 Setter 메서드를 허용하는 것이 안전하지 않다고 판단하기 때문이다. 그렇다면 Setter 메서드 없이 어떻게 엔티티에 값을 저장할 수 있을까?

엔티티는 생성자에 의해서만 엔티티의 값을 저장할 수 있게 하고, 데이터를 변경해야 할 경우에는 메서드를 추가로 작성하면 된다. 다만, 이 책은 복잡도를 낮추고 원활한 설명을 위해 엔티티에 Setter 메서드를 추가하여 진행

---